name: üöÄ TestFlight iOS Deploy

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      build_number:
        description: 'Custom build number (optional)'
        required: false
        type: string
      environment:
        description: 'Deployment environment'
        required: false
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  FLUTTER_VERSION: '3.32.3' # Adjust as needed
  XCODE_VERSION: '15.2'    # Adjust as needed

jobs:
  testflight-deploy:
    name: Build & Upload to TestFlight
    runs-on: macos-14
    timeout-minutes: 60

    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üîç Validate All Variables & Secrets
        run: |
          echo "üîç Validating environment variables and secrets..."
          echo "==========================================="
          
          # Environment Variables
          echo "üìã Environment Variables:"
          echo "  FLUTTER_VERSION: ${{ env.FLUTTER_VERSION }}"
          echo "  XCODE_VERSION: ${{ env.XCODE_VERSION }}"
          echo "  GitHub Run Number: ${{ github.run_number }}"
          echo "  GitHub Run Attempt: ${{ github.run_attempt }}"
          
          # Check for required secrets (without revealing values)
          echo ""
          echo "üîê Secret Validation:"
          
          MISSING_SECRETS=()
          
          if [ -z "${{ secrets.APPLE_API_PRIVATE_KEY }}" ]; then
            echo "  ‚ùå APPLE_API_PRIVATE_KEY: Missing"
            MISSING_SECRETS+=("APPLE_API_PRIVATE_KEY")
          else
            PRIVATE_KEY_VALUE="${{ secrets.APPLE_API_PRIVATE_KEY }}"
            PRIVATE_KEY_LENGTH=${#PRIVATE_KEY_VALUE}
            echo "  ‚úÖ APPLE_API_PRIVATE_KEY: Present ($PRIVATE_KEY_LENGTH chars)"
            # Check if it looks like a valid private key
            if [[ "$PRIVATE_KEY_VALUE" == *"BEGIN PRIVATE KEY"* ]]; then
              echo "     üîë Format: Valid private key detected"
            else
              echo "     ‚ö†Ô∏è Format: May not be a valid private key"
            fi
          fi
          
          if [ -z "${{ secrets.API_KEY_ID }}" ]; then
            echo "  ‚ùå API_KEY_ID: Missing"
            MISSING_SECRETS+=("API_KEY_ID")
          else
            API_KEY_VALUE="${{ secrets.API_KEY_ID }}"
            KEY_ID_LENGTH=${#API_KEY_VALUE}
            echo "  ‚úÖ API_KEY_ID: Present ($KEY_ID_LENGTH chars)"
            if [ $KEY_ID_LENGTH -eq 10 ]; then
              echo "     üìè Length: Correct (10 characters)"
            else
              echo "     ‚ö†Ô∏è Length: Expected 10 characters, got $KEY_ID_LENGTH"
            fi
          fi
          
          if [ -z "${{ secrets.ISSUER_ID }}" ]; then
            echo "  ‚ùå ISSUER_ID: Missing"
            MISSING_SECRETS+=("ISSUER_ID")
          else
            ISSUER_VALUE="${{ secrets.ISSUER_ID }}"
            ISSUER_LENGTH=${#ISSUER_VALUE}
            echo "  ‚úÖ ISSUER_ID: Present ($ISSUER_LENGTH chars)"
            if [[ "$ISSUER_VALUE" =~ ^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$ ]]; then
              echo "     üÜî Format: Valid UUID format"
            else
              echo "     ‚ö†Ô∏è Format: Should be UUID format (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)"
            fi
          fi
          
          if [ -z "${{ secrets.TEAM_ID }}" ]; then
            echo "  ‚ùå TEAM_ID: Missing"
            MISSING_SECRETS+=("TEAM_ID")
          else
            TEAM_VALUE="${{ secrets.TEAM_ID }}"
            TEAM_ID_LENGTH=${#TEAM_VALUE}
            echo "  ‚úÖ TEAM_ID: Present ($TEAM_ID_LENGTH chars)"
            if [ $TEAM_ID_LENGTH -eq 10 ]; then
              echo "     üìè Length: Correct (10 characters)"
            else
              echo "     ‚ö†Ô∏è Length: Expected 10 characters, got $TEAM_ID_LENGTH"
            fi
          fi
          
          if [ -z "${{ secrets.APP_ID }}" ]; then
            echo "  ‚ùå APP_ID: Missing"
            MISSING_SECRETS+=("APP_ID")
          else
            echo "  ‚úÖ APP_ID: Present (${{ secrets.APP_ID }})"
            if [[ "${{ secrets.APP_ID }}" =~ ^[a-zA-Z0-9.-]+\.[a-zA-Z0-9.-]+$ ]]; then
              echo "     üì± Format: Valid bundle identifier format"
            else
              echo "     ‚ö†Ô∏è Format: Should be reverse domain format (com.company.app)"
            fi
          fi
          
          # Check workflow inputs
          echo ""
          echo "‚öôÔ∏è Workflow Inputs:"
          if [ -n "${{ github.event.inputs.build_number }}" ]; then
            echo "  üìã Custom Build Number: ${{ github.event.inputs.build_number }}"
          else
            BUILD_NUMBER="${{ format('{0}.{1}', github.run_number, github.run_attempt) }}"
            echo "  üìã Auto Build Number: $BUILD_NUMBER"
          fi
          echo "  üåç Environment: ${{ github.event.inputs.environment || 'production' }}"
          
          # Project structure validation
          echo ""
          echo "üìÅ Project Structure:"
          MISSING_FILES=()
          
          if [ ! -f "pubspec.yaml" ]; then
            echo "  ‚ùå pubspec.yaml: Missing"
            MISSING_FILES+=("pubspec.yaml")
          else
            echo "  ‚úÖ pubspec.yaml: Found"
            # Extract app version
            APP_VERSION=$(grep '^version: ' pubspec.yaml | cut -d ' ' -f 2 | cut -d '+' -f 1 || echo "unknown")
            echo "     üì± App Version: $APP_VERSION"
          fi
          
          if [ ! -f "ios/Runner/Info.plist" ]; then
            echo "  ‚ùå ios/Runner/Info.plist: Missing"
            MISSING_FILES+=("ios/Runner/Info.plist")
          else
            echo "  ‚úÖ ios/Runner/Info.plist: Found"
            # Extract bundle ID from plist
            if command -v plutil > /dev/null 2>&1; then
              PLIST_BUNDLE_ID=$(plutil -extract CFBundleIdentifier raw ios/Runner/Info.plist 2>/dev/null || echo "unknown")
              echo "     üì± Bundle ID in plist: $PLIST_BUNDLE_ID"
              
              # Check if APP_ID matches plist bundle ID
              if [ -n "${{ secrets.APP_ID }}" ] && [ "$PLIST_BUNDLE_ID" != "${{ secrets.APP_ID }}" ]; then
                echo "     ‚ö†Ô∏è Warning: APP_ID secret (${{ secrets.APP_ID }}) doesn't match plist ($PLIST_BUNDLE_ID)"
              fi
            fi
          fi
          
          if [ ! -d "ios" ]; then
            echo "  ‚ùå ios/: Missing"
            MISSING_FILES+=("ios/")
          else
            echo "  ‚úÖ ios/: Found"
          fi
          
          if [ ! -f "ios/Podfile" ]; then
            echo "  ‚ö†Ô∏è ios/Podfile: Missing (might be needed)"
          else
            echo "  ‚úÖ ios/Podfile: Found"
          fi
          
          # Final validation summary
          echo ""
          echo "üìä Validation Summary:"
          echo "====================="
          
          if [ ${#MISSING_SECRETS[@]} -eq 0 ]; then
            echo "‚úÖ All required secrets are present"
          else
            echo "‚ùå Missing secrets: ${MISSING_SECRETS[*]}"
            echo "   Please add these secrets in GitHub Settings > Secrets and variables > Actions"
          fi
          
          if [ ${#MISSING_FILES[@]} -eq 0 ]; then
            echo "‚úÖ All required project files are present"
          else
            echo "‚ùå Missing project files: ${MISSING_FILES[*]}"
          fi
          
          # Exit if critical issues found
          if [ ${#MISSING_SECRETS[@]} -ne 0 ] || [ ${#MISSING_FILES[@]} -ne 0 ]; then
            echo ""
            echo "‚ùå VALIDATION FAILED - Cannot proceed with deployment"
            echo "   Please fix the issues above and try again."
            exit 1
          fi
          
          echo "‚úÖ VALIDATION PASSED - Ready to proceed with deployment"

      - name: üîß Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: ${{ env.XCODE_VERSION }}

      - name: üê¶ Setup Flutter SDK
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ env.FLUTTER_VERSION }}
          cache: true
          cache-key: flutter-${{ env.FLUTTER_VERSION }}

      - name: üîé Run Flutter Doctor
        run: flutter doctor -v

      - name: üîë Validate & Prepare Apple API Key
        run: |
          # Check for essential secrets
          if [ -z "${{ secrets.APPLE_API_PRIVATE_KEY }}" ] || \
             [ -z "${{ secrets.API_KEY_ID }}" ] || \
             [ -z "${{ secrets.ISSUER_ID }}" ] || \
             [ -z "${{ secrets.APP_ID }}" ]; then
            echo "‚ùå One or more required secrets are missing. Please check your repository secrets."
            exit 1
          fi
          echo "‚úÖ All required secrets are present."

          # Create private_keys directory and .p8 file
          mkdir -p private_keys
          
          # Process the private key with multiple methods to ensure proper format
          PRIVATE_KEY="${{ secrets.APPLE_API_PRIVATE_KEY }}"
          echo "üîç Processing private key (length: ${#PRIVATE_KEY} chars)..."
          
          # Method 1: Direct echo with printf to handle \n correctly
          printf '%s\n' "$PRIVATE_KEY" | sed 's/\\n/\n/g' > private_keys/AuthKey_${{ secrets.API_KEY_ID }}.p8
          
          # Set proper permissions
          chmod 600 private_keys/AuthKey_${{ secrets.API_KEY_ID }}.p8
          
          # Debug: Show first and last lines
          echo "üîç First line of key file:"
          head -1 private_keys/AuthKey_${{ secrets.API_KEY_ID }}.p8
          echo "üîç Last line of key file:"
          tail -1 private_keys/AuthKey_${{ secrets.API_KEY_ID }}.p8
          echo "üîç Total lines in key file: $(wc -l < private_keys/AuthKey_${{ secrets.API_KEY_ID }}.p8)"
          
          # Verify the key file format
          if head -1 private_keys/AuthKey_${{ secrets.API_KEY_ID }}.p8 | grep -q "BEGIN PRIVATE KEY"; then
            echo "‚úÖ Private key header detected"
          else
            echo "‚ùå Missing private key header"
            echo "üîç Full key file content:"
            cat private_keys/AuthKey_${{ secrets.API_KEY_ID }}.p8
            echo "‚ùå Trying alternative processing method..."
            
            # Method 2: Use base64 decode if the key was base64 encoded
            if echo "$PRIVATE_KEY" | base64 -d > /tmp/test_key 2>/dev/null && head -1 /tmp/test_key | grep -q "BEGIN PRIVATE KEY"; then
              echo "üîÑ Key appears to be base64 encoded, decoding..."
              echo "$PRIVATE_KEY" | base64 -d > private_keys/AuthKey_${{ secrets.API_KEY_ID }}.p8
              chmod 600 private_keys/AuthKey_${{ secrets.API_KEY_ID }}.p8
            else
              echo "‚ùå Key is not valid base64 either"
              exit 1
            fi
            rm -f /tmp/test_key
          fi
          
          # Final verification
          if head -1 private_keys/AuthKey_${{ secrets.API_KEY_ID }}.p8 | grep -q "BEGIN PRIVATE KEY" && \
             tail -1 private_keys/AuthKey_${{ secrets.API_KEY_ID }}.p8 | grep -q "END PRIVATE KEY"; then
            echo "‚úÖ Apple API key file created and verified successfully."
          else
            echo "‚ùå Final verification failed. Key file does not have proper BEGIN/END markers."
            echo "üîç Key file content:"
            cat private_keys/AuthKey_${{ secrets.API_KEY_ID }}.p8
            exit 1
          fi

      - name: üéØ Generate JWT Token & Get Team ID
        run: |
          cd cli
          dart pub get
          cd ..
          
          # Generate JWT token using Dart CLI
          JWT=$(dart run ./cli/bin/cli.dart "${{ secrets.API_KEY_ID }}" "${{ secrets.ISSUER_ID }}" "private_keys/AuthKey_${{ secrets.API_KEY_ID }}.p8")
          echo "JWT_TOKEN=${JWT}" >> $GITHUB_ENV
          
          # Get Team ID from App Store Connect API
          TEAM_RESPONSE=$(curl -s -H "Authorization: Bearer ${JWT}" "https://api.appstoreconnect.apple.com/v1/bundleIds")
          TEAM_ID=$(echo "${TEAM_RESPONSE}" | jq -r '.data[0].attributes.seedId')
          echo "TEAM_ID=${TEAM_ID}" >> $GITHUB_ENV
          
          echo "Successfully fetched Team ID: ${TEAM_ID}"

      - name: üì¶ Install Flutter & iOS Dependencies
        run: |
          flutter pub get
          cd ios && pod install --repo-update && cd ..
          echo "‚úÖ Dependencies installed."

      - name: üßπ Clean & Prepare Build
        run: |
          flutter clean
          flutter pub get
          # Determine build number (custom input or timestamp.run_number)
          BUILD_NUMBER="${{ github.event.inputs.build_number || format('{0}.{1}', github.run_number, github.run_attempt) }}"
          VERSION_NAME=$(grep '^version: ' pubspec.yaml | cut -d ' ' -f 2 | cut -d '+' -f 1)
          echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
          echo "VERSION_NAME=$VERSION_NAME" >> $GITHUB_ENV
          echo "üì± Building app version: ${VERSION_NAME} (Build: ${BUILD_NUMBER})"
          echo "‚úÖ Build environment prepared."

      - name: üèóÔ∏è Build iOS Archive
        run: |
          flutter build ios --release --no-codesign \
            --build-number="$BUILD_NUMBER" \
            --build-name="$VERSION_NAME"

          AUTH_KEY_PATH="$PWD/private_keys/AuthKey_${{ secrets.API_KEY_ID }}.p8"

          # Archive the app
          xcodebuild \
            -workspace ios/Runner.xcworkspace \
            -scheme Runner \
            -configuration Release \
            -archivePath build/ios/archive/Runner.xcarchive \
            -destination 'generic/platform=iOS' \
            -allowProvisioningUpdates \
            -authenticationKeyPath "$AUTH_KEY_PATH" \
            -authenticationKeyID "${{ secrets.API_KEY_ID }}" \
            -authenticationKeyIssuerID "${{ secrets.ISSUER_ID }}" \
            clean archive
          echo "‚úÖ iOS app archived successfully."

      - name: üì§ Export IPA
        run: |
          AUTH_KEY_PATH="$PWD/private_keys/AuthKey_${{ secrets.API_KEY_ID }}.p8"

          # Create export options plist
          cat > build/ios/archive/ExportOptions.plist << EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>method</key>
              <string>app-store</string>
              <key>teamID</key>
              <string>${{ env.TEAM_ID }}</string>
              <key>uploadBitcode</key>
              <false/>
              <key>uploadSymbols</key>
              <true/>
              <key>compileBitcode</key>
              <false/>
              <key>manageAppVersionAndBuildNumber</key>
              <false/>
          </dict>
          </plist>
          EOF

          # Export IPA
          xcodebuild \
            -exportArchive \
            -archivePath build/ios/archive/Runner.xcarchive \
            -exportPath build/ios/ipa \
            -exportOptionsPlist build/ios/archive/ExportOptions.plist \
            -allowProvisioningUpdates \
            -authenticationKeyPath "$AUTH_KEY_PATH" \
            -authenticationKeyID "${{ secrets.API_KEY_ID }}" \
            -authenticationKeyIssuerID "${{ secrets.ISSUER_ID }}"
          echo "‚úÖ IPA exported successfully."

      - name: üöÄ Upload to TestFlight
        run: |
          IPA_PATH=$(find build/ios/ipa -name "*.ipa" | head -n 1)
          if [ -z "$IPA_PATH" ]; then
            echo "‚ùå No IPA file found for upload."
            exit 1
          fi
          echo "üì± Found IPA: $IPA_PATH"

          xcrun altool \
            --upload-app \
            --type ios \
            --file "$IPA_PATH" \
            --apiKey "${{ secrets.API_KEY_ID }}" \
            --apiIssuer "${{ secrets.ISSUER_ID }}" \
            --verbose
          echo "üéâ Upload to TestFlight completed! Check App Store Connect for processing: https://appstoreconnect.apple.com/apps/${{ secrets.APP_ID }}/testflight"

      - name: üßπ Clean up Sensitive Files
        if: always()
        run: |
          echo "üßπ Cleaning up sensitive files..."
          rm -rf private_keys/
          rm -f build/ios/archive/ExportOptions.plist
          echo "‚úÖ Cleanup complete."